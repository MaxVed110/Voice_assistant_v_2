# Пояснительная записка. Работа в Python

## 1. Что такое Python? Основная информация

### 1.1. О языке

**Python** — высокоуровневый язык программирования общего назначения с динамической строгой типизацией и автоматическим
управлением памятью, ориентированный на повышение производительности разработчика, читаемости кода и его качества. Язык
является полностью объектно-ориентированным в том плане, что всё является объектами. *Необычной особенностью* языка
является выделение блоков кода пробельными отступами. Синтаксис ядра языка минималистичен, за счёт чего на практике
редко возникает необходимость обращаться к документации. Сам же язык известен как интерпретируемый и используется в том
числе для написания скриптов.

*Каковы особенности Python?*

`Интерпретируемый язык`
Python является интерпретируемым языком, то есть он выполняет код построчно. Если в коде программы присутствуют ошибки,
она перестает работать. Это позволяет программистам быстро найти ошибки в коде.

`Простой в использовании язык`
Python использует слова, подобные словам английского языка. В отличие от других языков программирования, в Python не
используются фигурные скобки. Вместо них применяется отступ.

`Язык с динамической типизацией`
Программистам не нужно объявлять типы переменных при написании кода, потому что Python определяет их во время
выполнения. Эта функция позволяет писать программы на Python значительно быстрее.

`Язык высокого уровня`
Python ближе к естественным языкам, чем ряд других языков программирования. Благодаря этому программистам не нужно
беспокоиться о его базовой функциональности, например об архитектуре и управлении памятью.

`Объектно-ориентированный язык`
Python рассматривает все элементы как объекты, но также поддерживает другие типы программирования (например, структурное
и функциональное программирование).

### 1.2 Настройка, установка, PyCharm

**Python** является интерпретируемым ЯП, поэтому перед тем, как начать изучать синтаксис необходимо установить
интерпретатор с официального [сайта](https://www.python.org/)

Для Windows версии 8 и выше можно устанавливать последнюю версию, для более ранних версий – не выше 3.8. На иных ОС(
macOS и Linux) интерпретатор является предустановленным.

После установки откройте командную строку `cmd`, введите слово *“python”*, если все успешно установилось у Вас выведется
соответствующее сообщение.

Для эффективной и удобной работы необходимо иметь среду разработки. Наиболее популярными для этого языка являются VS
Code и PyCharm.

**VS Code** отличается простотой работы при написании небольших скриптов, для более крупного проекта необходима **
PyCharm**. Ее настройка предельно проста: следует скачать бесплатную версию с официального сайта и следовать инструкции.

*Функции PyCharm*:

1. Автоматическое завершение и проверка кода
2. Обработка и быстрое устранение ошибок
3. Чистка кода без изменения функциональных возможностей
4. Поддержка платформ интернет-приложений, таких как Django и Flask
5. Поддержка других языков программирования, таких как JavaScript, CoffeeScript, TypeScript, AngularJS и Node
6. Научные инструменты и библиотеки, такие как Matplotlib и NumPy
7. Возможность запуска, отладки, тестирования и развертывания приложений на удаленных виртуальных машинах
8. Отладчик для поиска ошибок в коде, профилировщик для выявления проблем с производительностью и средство запуска
   модульных тестов
9. Поддержка баз данных

### 1.3 Операторы ввода-вывода данных (базовые типы)

Синтаксис Python предельно простой: он не требует постановки; в конце строк, а из-за динамической типизации – и
объявления переменных.

Функция вывода данных -

```
print(var1, var2, var3) 
```

выводит данные на экран, где var1, var2, va3 - переменные или значения.

Функция ввода данных –

```
input()
```

присваивает переменной вводимую пользователем информацию в строковом типе.
Если необходимо таким образом ввести число – необходимо использовать встроенную функцию int(input()) – в целое число (
если возможно). Аналогично str() в строковый и float() в вещественный.

*Базовые типы данных*

1. int - Целые числа
2. float - Дробные числа
3. bool - Логический тип данных (True/False)
4. str - Строка

*Объявление переменной*

`название переменной = значение переменной` (один знак равенства обозначает присвоение значения к переменной)

```
a = 123
b = 333
print(a+b)

# 456
```

Нельзя указать переменную, не присвоив ей какое-либо значение. Но можно присвоить значение `None` и использовать
переменную дальше по коду.
Если необходимо узнать тип данных переменной – функция type().

`print(type(name))` - функция, которая указывает на тип данных
Для комментирования строк используется символ `#`

### 1.4 Арифметические и логические операции

В Python существуют следующие обозначения арифметических операций, приоритет операций - по правилам алгебры:

```
+ - сложение
- - вычитание
* - умножение
/ - деление (по умолчанию вещественное)
% - остаток от деления
// - целочисленное деление
** - возведение в степень
```

При это для округления результата до требуемого количества знаков используется функция `round()`

```
 c = round(a * b, 5) 
 # 3,29633.
 ```

Сокращение операций выглядит так: a"знак"=5, т.е а = а "знак" 5

```
a+=5 -> a = a + 5

```

Логические операции (позволяют сравнивать не только числа, но и строки. Используются правила логики, результат – True
или Falls):

```
>   - больше
>=  - больше или равно
<   - меньше
<=  - меньше или равно
==  - равно
!=  - не равно
not - не (отрицание)
and - и
or  - или
```

### 1.5 Управляющие конструкции (условия)

Т.к. в языке не используются фигурные скобки, то большое значение приобретают отступы.

Блок кода, который находится внутри оператора условия или цикла, функция, отделяется 4 пробелами или 1 TAB.

Операторами условия являются *if, else, elif* для множественного условия.

```
if ...:
    # operator
elif ...:
    # operator
else:
    # operator
```

Для сложных условий применяются логические операторы *and, or* и *not*.

### 1.6 Цикл while

Первый вид цикла – код выполняется, пока выполняется условие, указанное после *while*.

```
while condition:
    # operator
    # operator
```

### 1.7. Цикл for

Второй тип цикла, часто использующийся для перебора значений.
Возможно использование для перебора значений в итерируемых объектах (строка, список):

```
fot i in 'qeqrqrq':
    print(i)
# q
# e ...
```

Или с использованием итератора и функции `range()`, задающей диапазон.

Range выдает значения из диапазона с шагом 1. Если указано только одно число — от 0 до заданного числа. Если нужен
другой шаг, третьим аргументов можно задать приращение.

```
fot i in range(4):
    print(i)
# 0
# 1 ...
```

## 2. Данные, функции, модули

### 2.1. Списки

**Список** — это упорядоченный конечный набор элементов. По сути список - это тот же самый массив, в котором можно
хранить элементы любых типов данных.
*Как работать со списками?*

```
list_1 = [] # Создание пустого списка list_2 = list() # Создание пустого списка list_1 = [7, 9, 11, 13, 15, 17]
```

В списках существует нумерация, которая начинается с 0.
`list_1.append(n)` - сохранение элемента в конец списка – заполнение во время работы.
Чтобы узнать количество элементов в списке необходимо использовать функцию `len(имя_списка)`.

### 2.2. Кортежи

**Кортеж** — это неизменяемый список. Тогда для чего нужны кортежи, если их нельзя изменить? В случае защиты каких-либо
данных от изменений (намеренных или случайных). Кортеж занимает меньше места в памяти и работают быстрее, по сравнению
со списками.

```
t = () # создание пустого кортежа 
print(type(t)) # class <'tuple'>
```

### 2.3. Словари

**Словари** — неупорядоченные коллекции произвольных объектов с доступом по ключу. В списках в качестве ключа
используется индекс элемента. В словаре для определения элемента используется значение ключа (строка, число)

```
dictionary = {} 
dictionary = {'up': '↑', 'left': '←', 'down': '↓', 'right': '→'} 

print(dictionary) # {'up':'↑', 'left':'←', 'down':'↓', 'right':'→'} 
```

### 2.4. List Comprehension

**List Comprehension** — это упрощенный подход к созданию списка, который задействует цикл *for*, а также инструкции *
if-else* для определения того, что в итоге окажется в финальном списке.

```
Список: list_1 = [exp for item in iterable] 
Выборка по заданному условию: list_1 = [exp for item in iterable (if conditional)]
```

## 3. Функциональное программирование

### 3.1. От процедурного к функциональному программированию

До появления этой парадигмы весь код программы писался последовательно большими блоками. Это приводило к тому, что в
программе появлялось большое количество одинаковых участков кода, загрязняющих и усложняющих его. В результате появилась
идея объединить такие блоки, выполняющие одинаковые задачи, в один – **функцию**.

### 3.2. Функции

**Функция в программировании** — это часть программного кода, который несет в себе набор инструкций или команд, решающих
конкретную задачу.

К функциям можно обращаться из *разных мест программы*, а они в ответ возвращают какие-то значения. За счет этой
возможности один и тот же алгоритм действий не нужно прописывать в разных частях кода, потому что достаточно будет
только написать имя функции.

```
def function_name(arg):
    # operator
    # operator
    return x (optional)
```

Функция может `принимать` или `не принимать` аргументы и `возвращать` или `не возвращать` (в таком случае метод)
значения, также задаются значения по умолчанию.

### 3.3. Рекурсия

**Рекурсия** — это функция, вызывающая сама себя. При описании рекурсии важно указать, когда функции надо остановиться и
перестать вызывать саму себя. По-другому говоря, необходимо указать базис рекурсии

```
def fibo(n):
    if n in (1,2):
        return 1
    return fibo(n-1) + fibo(n-2)    
```

## 4. Библиотеки, pip

### 4.1. Встроенные библиотеки и работа с файлами

*Библиотека в программировании* — сборник подпрограмм или объектов, используемых для разработки программного
обеспечения, или ПО.

**Модули**(*библиотеки*) в Python устроены по иерархическому принципу, как каталоги в файловой системе. Один модуль
может быть вложен в другой, причем вложенность не ограничена (хотя на практике редко бывает больше 4). Чтобы
пользоваться функциями, объектами и классами из модуля, весь этот модуль или его часть нужно подключить к программе
— `импортировать`.

```
Правило: не импортируйте то, чем не пользуетесь.
```

За импорт в Python отвечает директива `import`.

*Графические библиотеки*

С Python поставляется библиотека **tkinter** на основе Tcl/Tk для создания кроссплатформенных программ с графическим
интерфейсом.

```
from tkinter import *
from tkinter import ttk
root = Tk()
frm = ttk.Frame(root, padding=10)
frm.grid()
ttk.Label(frm, text="Hello World!").grid(column=0, row=0)
ttk.Button(frm, text="Quit", command=root.destroy).grid(column=1, row=0)
root.mainloop()
```

*Модуль os*

Модуль *os* предоставляет множество функций для работы с операционной системой. Для того чтобы начать работать с данным
модулем необходимо его импортировать в свою программу: `import os`.

*Познакомимся с базовыми функциями данного модуля:*

1. os.chdir(path) - смена текущей директории.
   `import os os.chdir('C:/Users/Qwer/PycharmProjects/AA')`
2. os.getcwd() - текущая рабочая директория
   `import os print(os.getcwd()) # 'C:\Users\79190\PycharmProjects\webproject\'`
3. os.path - является вложенным модулем в модуль os и реализует некоторые полезные функции для работы с путями, такие
   как:
   *os.path.basename(path)* - базовое имя пути
   `import os print(os.path.basename('C:/Users/Qwer/PycharmProjects/webproject/main.py')) #'main.py' `
4. os.path.abspath(path) - возвращает нормализованный абсолютный путь.
   `import os print(os.path.abspath('main.py')) # 'C:/Users/79190/PycharmProjects/webproject/main.py'`

Комбинированием двух этих библиотек можно создать возможность пользователю самостоятельно работать с файлами.

### 4.2. Что такое pip?

[**PyPI**](https://pypi.org/) — центральный репозиторий (хранилище) модулей для языка программирования Python. Он как
PlayMarket для Android, AppStore для iPhone или CPAN для Perl.

*pip* - команда, необходимая для установки необходимых библиотек из него.

### 4.3. Установка библиотек с PyPi

Для установки пакетов в Python служит специальная утилита командной строки *pip*, которая является еще и модулем.
Чтобы установить пакет, нужно выполнить команду `pip install <Имя модуля>`. Пакет будет скачан с PyPI и установлен:

<image src="/Voice_assistant_v_2/pip.png" alt="Установка с PyPi">

### 4.4. Пример внешних библиотек

*Работа со звуком*
Для анализа голоса человека, произносимого, например, в микрофон и перевода его в текстовый вид, используется
библиотека *speech_recognition*

```
import speech_recognition

sr = speech_recognition.Recognizer()
with speech_recognition.Microphone() as micro:
    sr.adjust_for_ambient_noise(source=micro, duration=0.5)
    audio = self.sr.listen(source=micro, timeout=5, phrase_time_limit=5)  
    audio = sr.listen(source=micro)
    phrase = self.sr.recognize_google(audio_data=audio, language='ru-RU').lower()
    return phrase
```

*Графика* Для создания графического оконного интерфейса существует более удобная по сравнению с tkinter библиотека *
pyqt5*

## 5. Исключения

### 5.1. Что представляет собой ошибка?

**Программная ошибка** — означает ошибку в программе или в системе, из-за которой программа выдает неожиданное
поведение и, как следствие, результат. Большинство программных ошибок возникают из-за ошибок, допущенных разработчиками
программы в её исходном коде, либо в её дизайне. Также некоторые ошибки возникают из-за некорректной работы инструментов
разработчика, например из-за компилятора, вырабатывающего некорректный код.

### 5.2. Оповещение об ошибках с помощью исключений

**Исключения** — это специальный тип объектов, которые создаются при возникновении ошибочной ситуации и выбрасываются
компилятором.

<image src="/Voice_assistant_v_2/exception.png" alt="Выброс исключения">

В стектрейсе ошибки видна последовательность выброса исключений и его тип - NameError

### 5.3. Типы исключений

Существует несколько стандартных типов исключений:

```
SyntaxError — Ошибка в синтаксисе программы
NameError — Ошибка обращения к несуществующей переменной
AttributeError — Ссылка на атрибут не работает
TypeError — Операнд не имеет правильного типа
ValueError — Неверный тип у значения переменной
IOError — Ошибка в подсистеме системе ввода вывода
ZeroDivisionError — Ошибка деления на ноль
```

Более подробно структура представлена в [документации](https://docs.python.org/3/tutorial/errors.html).

### 5.4. Обработка исключение try-except

Язык имеет встроенную конструкцию для работы с исключениями. Обработка происходит с помощью блока *try-except*.

Блок *try-except* заставляет Python выполнить код внутри него, но также говорит, что делать в случае, если будет вызвано
исключение. Когда используется *try-except*, программа будет продолжать работать, даже если возникнут какие-нибудь
ошибки. Вместо Traceback программа будет обрабатывать код, представленный в блоке *except*.

```
try:
     first = int(input("Напишите любое целое число: "))
     second = int(input("Введите еще одно число: "))
     print(first/second)
except ZeroDivisionError:
     print("Разделить число на ноль - невозможно!")
```

В конструкции try-except есть дополнительный, но не обязательный оператор *finally*. Код внутри этого блока выполняется
перед завершением конструкции try-except, вне зависимости от того какие исключения были обработаны, а какие нет.

```
try:
     first = int(input("Напишите любое целое число: "))
     second = int(input("Введите еще одно число: "))
     print(first/second)
except ZeroDivisionError:
     print("Разделить число на ноль - невозможно!")
except ValueError:
     print("Неправильный тип переменной")
finally:
     print("Работа программы завершена")
```

## 6. ООП

### 6.1. Что такое ООП?

**Объектно-ориентированное программирование** — методология программирования, основанная на представлении программы в
виде совокупности взаимодействующих объектов, каждый из которых является экземпляром определённого класса, а классы
образуют иерархию наследования.

*Идеологически*, ООП — подход к программированию как к моделированию информационных объектов, решающий на новом уровне
основную задачу структурного программирования: структурирование информации с точки зрения управляемости, что существенно
улучшает управляемость самим процессом моделирования, что, в свою очередь, особенно важно при реализации крупных
проектов.

### 6.2. ООП в Python

Дизайн языка Python построен *вокруг объектно-ориентированной модели программирования*. Реализация ООП в Python является
хорошо продуманной, но вместе с тем достаточно специфической по сравнению с другими объектно-ориентированными языками.

В языке всё является `объектами` — либо экземплярами классов, либо экземплярами метаклассов. Исключением является
базовый встроенный метакласс *type*. Таким образом, классы на самом деле являются экземплярами метаклассов, а
производные метаклассы являются экземплярами метакласса type.

Метаклассы являются частью концепции метапрограммирования и предоставляют возможность управления наследованием классов,
что позволяет создавать абстрактные классы, регистрировать классы или добавлять в них какой-либо программный интерфейс в
рамках библиотеки или фреймворка.

**Классы** по своей сути представляют план или описание того, как создать объект, и хранят в себе описание атрибутов
объекта и методов для работы с ним. Парадигма ООП основывается на `инкапсуляции, наследовании и полиморфизме`.

*Инкапсуляция в Python* представлена возможностью хранения публичных и скрытых атрибутов (полей) в объекте с
предоставлением методов для работы с ними, при этом на самом деле все атрибуты являются публичными, но для пометки
скрытых атрибутов существует соглашение об именовании.

*Наследование* позволяет создавать производные объекты без необходимости повторного написания кода, а полиморфизм
заключается в возможности переопределения любых методов объекта (в Python все методы являются виртуальными), а также в
перегрузке методов и операторов. Перегрузка методов в Python реализуется за счёт возможности вызова одного и того же
метода с разным набором аргументов. Особенностью Python является возможность модифицировать классы после их объявления,
добавляя в них новые атрибуты и методы, также можно модифицировать и сами объекты, в результате чего классы могут
использоваться как структуры для хранения произвольных данных.

### 6.3. SOLID

ООП позволило программистам комбинировать сущности, объединённые некоей общей целью или функционалом, в отдельных
классах, рассчитанных на решение самостоятельных задач и независимых от других частей приложения. Однако само по себе
применение ООП не означает, что разработчик застрахован от возможности создания непонятного, запутанного кода, который
тяжело поддерживать. Роберт Мартин, для того, чтобы помочь всем желающим разрабатывать качественные ООП-приложения,
разработал пять принципов объектно-ориентированного программирования и проектирования, говоря о которых, используют
акроним *SOLID*.

```
S: Single Responsibility Principle (Принцип единственной ответственности).
O: Open-Closed Principle (Принцип открытости-закрытости).
L: Liskov Substitution Principle (Принцип подстановки Барбары Лисков).
I: Interface Segregation Principle (Принцип разделения интерфейса).
D: Dependency Inversion Principle (Принцип инверсии зависимостей).
```

*Принцип единственной ответственности*

Класс должен быть ответственен лишь за что-то одно. Если класс отвечает за решение нескольких задач, его подсистемы,
реализующие решение этих задач, оказываются связанными друг с другом. Изменения в одной такой подсистеме ведут к
изменениям в другой.

*Принцип открытости-закрытости*

Программные сущности (классы, модули, функции) должны быть открыты для расширения, но не для модификации.

*Принцип подстановки Барбары Лисков*

Цель этого принципа заключаются в том, чтобы классы-наследники могли бы использоваться вместо родительских классов, от
которых они образованы, не нарушая работу программы. Если оказывается, что в коде проверяется тип класса, значит принцип
подстановки нарушается.

*Принцип разделения интерфейса*

Создавайте узкоспециализированные интерфейсы, предназначенные для конкретного клиента. Клиенты не должны зависеть от
интерфейсов, которые они не используют.

Этот принцип направлен на устранение недостатков, связанных с реализацией больших интерфейсов.

*Принцип инверсии зависимостей*

Объектом зависимости должна быть абстракция, а не что-то конкретное.

Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.

Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.
